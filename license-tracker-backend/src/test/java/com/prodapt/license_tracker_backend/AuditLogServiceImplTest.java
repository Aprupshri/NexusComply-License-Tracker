package com.prodapt.license_tracker_backend;


import com.prodapt.license_tracker_backend.dto.AuditLogResponse;
import com.prodapt.license_tracker_backend.dto.CreateAuditLogRequest;
import com.prodapt.license_tracker_backend.entities.AuditLog;
import com.prodapt.license_tracker_backend.entities.enums.AuditAction;
import com.prodapt.license_tracker_backend.entities.enums.EntityType;
import com.prodapt.license_tracker_backend.exception.ResourceNotFoundException;
import com.prodapt.license_tracker_backend.repository.AuditLogRepository;
import com.prodapt.license_tracker_backend.service.implementation.AuditLogServiceImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuditLogServiceImplTest {

    @Mock
    private AuditLogRepository auditLogRepository;

    @InjectMocks
    private AuditLogServiceImpl auditLogService;

    @Captor
    private ArgumentCaptor<AuditLog> auditLogCaptor;

    private AuditLog mockAuditLog;
    private Page<AuditLog> mockAuditLogPage;
    private Pageable pageable;

    @BeforeEach
    void setUp() {
        pageable = Pageable.unpaged();

        mockAuditLog = AuditLog.builder()
                .logId(1L)
                .userId(100L)
                .username("test-user")
                .entityType(EntityType.LICENSE)
                .entityId("LIC-123")
                .action(AuditAction.CREATE)
                .details("{\"key\":\"value\"}")
                .ipAddress("127.0.0.1")
                .userAgent("Test-Agent")
                .timestamp(LocalDateTime.now())
                .build();

        mockAuditLogPage = new PageImpl<>(List.of(mockAuditLog), pageable, 1);
    }

    @Test
    @DisplayName("log with CreateAuditLogRequest should save correct audit log")
    void log_WithRequestObject_ShouldSaveLog() {
        // Arrange
        CreateAuditLogRequest request = CreateAuditLogRequest.builder()
                .userId(100L)
                .username("test-user")
                .entityType(EntityType.LICENSE)
                .entityId("LIC-123")
                .action(AuditAction.CREATE)
                .details("{\"key\":\"value\"}")
                .ipAddress("127.0.0.1")
                .userAgent("Test-Agent")
                .build();

        // We don't mock 'save' to return anything since the method is void

        // Act
        auditLogService.log(request);

        // Assert
        // Use verify with timeout to handle the @Async call
        verify(auditLogRepository, timeout(1000)).save(auditLogCaptor.capture());

        AuditLog capturedLog = auditLogCaptor.getValue();
        assertNull(capturedLog.getLogId()); // ID is generated by DB
        assertEquals(request.getUserId(), capturedLog.getUserId());
        assertEquals(request.getUsername(), capturedLog.getUsername());
        assertEquals(request.getEntityType(), capturedLog.getEntityType());
        assertEquals(request.getAction(), capturedLog.getAction());
        assertEquals(request.getDetails(), capturedLog.getDetails());
        assertEquals(request.getIpAddress(), capturedLog.getIpAddress());
        assertNotNull(capturedLog.getTimestamp()); // Should be set by @Builder.Default
    }

    @Test
    @DisplayName("log with overloaded parameters should save correct audit log")
    void log_WithOverloadedParams_ShouldSaveLog() {
        // Arrange
        Long userId = 101L;
        String username = "another-user";
        EntityType entityType = EntityType.DEVICE;
        String entityId = "DEV-001";
        AuditAction action = AuditAction.UPDATE;
        String details = "{\"change\":\"status\"}";

        // Act
        auditLogService.log(userId, username, entityType, entityId, action, details);

        // Assert
        // Use verify with timeout to handle the @Async call
        verify(auditLogRepository, timeout(1000)).save(auditLogCaptor.capture());

        AuditLog capturedLog = auditLogCaptor.getValue();
        assertEquals(userId, capturedLog.getUserId());
        assertEquals(username, capturedLog.getUsername());
        assertEquals(entityType, capturedLog.getEntityType());
        assertEquals(entityId, capturedLog.getEntityId());
        assertEquals(action, capturedLog.getAction());
        assertEquals(details, capturedLog.getDetails());
        assertNull(capturedLog.getIpAddress()); // Not provided in this overload
    }

    @Test
    @DisplayName("getAllAuditLogs should return mapped page")
    void getAllAuditLogs_Success() {
        // Arrange
        when(auditLogRepository.findByOrderByTimestampDesc(pageable)).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.getAllAuditLogs(pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        AuditLogResponse response = result.getContent().get(0);
        assertEquals(mockAuditLog.getLogId(), response.getLogId());
        assertEquals(mockAuditLog.getUsername(), response.getUsername());
        assertEquals("LICENSE", response.getEntityType());
    }

    @Test
    @DisplayName("getAuditLogById should return response when found")
    void getAuditLogById_Success() {
        // Arrange
        when(auditLogRepository.findById(1L)).thenReturn(Optional.of(mockAuditLog));

        // Act
        AuditLogResponse response = auditLogService.getAuditLogById(1L);

        // Assert
        assertNotNull(response);
        assertEquals(1L, response.getLogId());
        assertEquals("test-user", response.getUsername());
        assertEquals("LIC-123", response.getEntityId());
    }

    @Test
    @DisplayName("getAuditLogById should throw ResourceNotFoundException when not found")
    void getAuditLogById_NotFound() {
        // Arrange
        when(auditLogRepository.findById(99L)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(ResourceNotFoundException.class, () -> {
            auditLogService.getAuditLogById(99L);
        });
    }

    @Test
    @DisplayName("getAuditLogsByUser should call repository and map results")
    void getAuditLogsByUser_Success() {
        // Arrange
        when(auditLogRepository.findByUserIdOrderByTimestampDesc(100L, pageable)).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.getAuditLogsByUser(100L, pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        assertEquals(100L, result.getContent().get(0).getUserId());
        verify(auditLogRepository).findByUserIdOrderByTimestampDesc(100L, pageable);
    }

    @Test
    @DisplayName("getAuditLogsByEntity should call repository and map results")
    void getAuditLogsByEntity_Success() {
        // Arrange
        when(auditLogRepository.findByEntityTypeAndEntityIdOrderByTimestampDesc(EntityType.LICENSE, "LIC-123", pageable))
                .thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.getAuditLogsByEntity(EntityType.LICENSE, "LIC-123", pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        assertEquals("LICENSE", result.getContent().get(0).getEntityType());
        assertEquals("LIC-123", result.getContent().get(0).getEntityId());
        verify(auditLogRepository).findByEntityTypeAndEntityIdOrderByTimestampDesc(EntityType.LICENSE, "LIC-123", pageable);
    }

    @Test
    @DisplayName("getAuditLogsByFilters should call repository and map results")
    void getAuditLogsByFilters_Success() {
        // Arrange
        LocalDateTime start = LocalDateTime.now().minusDays(1);
        LocalDateTime end = LocalDateTime.now();
        when(auditLogRepository.findByFilters(EntityType.LICENSE, AuditAction.CREATE, 100L, start, end, pageable))
                .thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.getAuditLogsByFilters(EntityType.LICENSE, AuditAction.CREATE, 100L, start, end, pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(auditLogRepository).findByFilters(EntityType.LICENSE, AuditAction.CREATE, 100L, start, end, pageable);
    }

    @Test
    @DisplayName("searchAuditLogs should call repository and map results")
    void searchAuditLogs_Success() {
        // Arrange
        String searchTerm = "test";
        when(auditLogRepository.searchAuditLogs(searchTerm, pageable)).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.searchAuditLogs(searchTerm, pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(auditLogRepository).searchAuditLogs(searchTerm, pageable);
    }

    @Test
    @DisplayName("searchByLicenseKey should call repository and map results")
    void searchByLicenseKey_Success() {
        // Arrange
        String licenseKey = "LIC-123";
        when(auditLogRepository.findByLicenseKey(licenseKey, pageable)).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.searchByLicenseKey(licenseKey, pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(auditLogRepository).findByLicenseKey(licenseKey, pageable);
    }

    @Test
    @DisplayName("searchByDeviceId should call repository and map results")
    void searchByDeviceId_Success() {
        // Arrange
        String deviceId = "DEV-001";
        when(auditLogRepository.findByDeviceId(deviceId, pageable)).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.searchByDeviceId(deviceId, pageable);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(auditLogRepository).findByDeviceId(deviceId, pageable);
    }

    @Test
    @DisplayName("advancedSearch should correctly parse enums and call repository")
    void advancedSearch_WithAllFilters_Success() {
        // Arrange
        String entityType = "LICENSE";
        String action = "CREATE";
        String username = "test-user";
        String licenseKey = "LIC-123";
        String deviceId = "DEV-001";
        LocalDateTime start = LocalDateTime.now().minusDays(1);
        LocalDateTime end = LocalDateTime.now();

        when(auditLogRepository.searchByAdvancedFilters(
                EntityType.LICENSE, AuditAction.CREATE, username, licenseKey, deviceId, start, end, pageable
        )).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.advancedSearch(
                entityType, action, username, licenseKey, deviceId, start, end, pageable
        );

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(auditLogRepository).searchByAdvancedFilters(
                EntityType.LICENSE, AuditAction.CREATE, username, licenseKey, deviceId, start, end, pageable
        );
    }

    @Test
    @DisplayName("advancedSearch should handle null filters")
    void advancedSearch_WithNullFilters_Success() {
        // Arrange
        when(auditLogRepository.searchByAdvancedFilters(
                null, null, null, null, null, null, null, pageable
        )).thenReturn(mockAuditLogPage);

        // Act
        Page<AuditLogResponse> result = auditLogService.advancedSearch(
                null, null, null, null, null, null, null, pageable
        );

        // Assert
        assertNotNull(result);
        assertEquals(1, result.getTotalElements());
        verify(auditLogRepository).searchByAdvancedFilters(
                null, null, null, null, null, null, null, pageable
        );
    }
}